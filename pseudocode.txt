import numpy as np
import math

function Penjumlahan_Matriks(matriks Matriks1, Matriks2) -> matriks
# mengembalikan hasil penjumlahan 2 buah matriks
    -> np.add(Matriks1, Matriks2)

function Transpose(matriks Matriks) -> matriks
# mengembalikan transpose dari matriks
    -> np.transpose(Matriks)

function RGB_to_GrayScale_Formula(integer R, G, B) -> integer
# fungsi untuk mengubah RGB menjadi GrayScale
    -> 0.29*R + 0.587*G + 0.114*B

function Matriks_RGB_to_GrayScale(matriks Mat_RGB) -> matriks
# Mengubah matriks RGB menjadi matriks GrayScale
    height, width, vec = Mat_RGB.shape
    Matriks_GrayScale = np.zeros((height, width))
    
    i travresal [0..height]
        j travresal [0..width]:
            Matriks_GrayScale[i][j] = round(RGB_to_GrayScale_Formula(Mat_RGB[i, j, 0], Mat_RGB[i, j, 1], Mat_RGB[i, j, 2]))
    -> Matriks_GrayScale

function Matriks_GrayScale_to_Co_Occurence(matriks Mat_GrayScale) -> matriks
# Mengubah matriks GrayScale menjadi matriks Co-Occurence
# menggunakan jarak 1 pixel dengan sudut 0 derajat
    height, width, = Mat_GrayScale.shape
    Matriks_Co_Occurence = np.zeros((256, 256))

    i travresal [0..height]:
        j travresal [width-1]:
            baris = Mat_GrayScale[i][j]
            kolom = Mat_GrayScale[i][j+1]
            Matriks_Co_Occurence[int(baris)][int(kolom)] += 1
    
    -> Matriks_Co_Occurence

def Matrix_Normalisation(Matriks):
# menormalisasi matriks
    baris, kolom = Matriks.shape
    Matriks_Norm = np.zeros((baris, kolom))
    
    # Menghitung jumlah seluruh elemen matriks
    sum = np.sum(Matriks)

    # Melakukan normalisasi matriks
    for i in range(baris):
        for j in range(kolom):
            Matriks_Norm[i][j] = Matriks[i][j] / sum

    return Matriks_Norm

def Texture_of_Image(Matriks):
# mengembalikan texture sebuah matriks co-occurence yang telah dinormalisasi
# contrast = sigma (P(i,j) * (i-j)^2)
# homogeneity = sigma (P(i,j) / (1 + (i-j)^2))
# entropy = -sigma ((P(i,j) * log(P(i,j))))
    # bonus
# dissimilarity = sigma (P(i,j) * |i-j|)
# ASM = sigma (P(i,j)^2)                            ASM = angular second moment
# energy = sqrt(ASM)

    Vektor = [0, 0, 0, 0, 0, 0]

    for i in range(256):
        for j in range(256):
            Vektor[0] += Matriks[i][j] * (pow(i-j, 2))                  # Vektor[0] = Contrast
            Vektor[1] += Matriks[i][j] / (1 + (pow(i-j, 2)))            # Vektor[1] = Homogeneity
            
            if Matriks[i][j] != 0:      # menghindari log(0) 
                Vektor[2] += Matriks[i][j] * math.log(Matriks[i][j])    # Vektor[2] = Entropy
            
            Vektor[3] += Matriks[i][j] * abs(i-j)                       # Vektor[3] = Dissimilarity
            Vektor[4] += pow(Matriks[i][j], 2)                          # Vektor[4] = ASM

    Vektor[2] *= -1
    Vektor[5] = math.sqrt(Vektor[4])                                    # Vektor[5] = Energy

    return Vektor

def Norm_Vektor(Vektor, jumlah_elemen):
# mengembalikan nilai norm/magnitude (panjang) sebuah vektor
    magnitude = 0
    for i in range(jumlah_elemen):
        magnitude += Vektor[i]**2
    return math.sqrt(magnitude)

def Cosine_Similarity(Vektor1, Vektor2):
# mengembalikan nilai cosine similarity dari 2 buah vektor
    sum = 0
    for i in range(6):
        sum += Vektor1[i] * Vektor2[i]

    return sum / (Norm_Vektor(Vektor1, 6) * Norm_Vektor(Vektor2, 6))

def Hasil_CBIR_Tekstur(matriks):
# mengembalikan hasil CBIR Tekstur dari gambar yang diinputkan
    matriks = Matriks_RGB_to_GrayScale(matriks)                     # Mengubah matriks RGB menjadi matriks GrayScale
    matriks = Matriks_GrayScale_to_Co_Occurence(matriks)            # Mengubah matriks GrayScale menjadi matriks Co-Occurence dengan jarak 1 pixel dan sudut 0 derajat
    matriks = Penjumlahan_Matriks(matriks, Transpose(matriks))      # Menjumlahkan matriks Co-Occurence dengan transpose-nya untuk mendapatkan matriks simetri
    matriks = Matrix_Normalisation(matriks)                         # Menormalisasi matriks
    vektor_Texture = Texture_of_Image(matriks)          # Menghitung vektor Contrast, Homogeneity, dan Entropy, Dissimilarity, ASM, dan Energy
    
    return vektor_Texture